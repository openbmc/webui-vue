(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{424:function(t,e,s){"use strict";s.r(e);var n=s(41),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"unit-testing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unit-testing"}},[t._v("#")]),t._v(" Unit Testing")]),t._v(" "),s("p",[t._v("The goal of a unit test is to improve code quality and assure future\ndevelopment or refactoring does not result in broken builds and functionality.\nTests that require consistent updating when refactoring code are likely tightly\ncoupled to the internals of the component.")]),t._v(" "),s("blockquote",[s("p",[t._v("Writing unit tests is a constant struggle between writing enough tests and\nnot writing too many. I call this the unit testing Goldilocks rule—not too\nmany, not too few, but just enough. Thousands of tests for a small\napplication can be as damaging to development time as no tests.")]),t._v(" "),s("p",[t._v("-- "),s("cite",[t._v("Ed Yerburgh, Testing Vue Applications (New York: Manning\nPublications, 2019)")])])]),t._v(" "),s("h2",{attrs:{id:"test-libraries"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#test-libraries"}},[t._v("#")]),t._v(" Test Libraries")]),t._v(" "),s("p",[t._v("The OpenBMC Web UI unit test framework uses the Jest test runner and relies on\nthe following libraries:")]),t._v(" "),s("ul",[s("li",[t._v("@vue/cli-plugin-unit-jest")]),t._v(" "),s("li",[t._v("@vue/test-utils")])]),t._v(" "),s("h2",{attrs:{id:"test-specification-location-and-naming-conventions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#test-specification-location-and-naming-conventions"}},[t._v("#")]),t._v(" Test specification location and naming conventions")]),t._v(" "),s("ul",[s("li",[t._v("Create the test files in the /tests/unit directory")]),t._v(" "),s("li",[t._v("The naming convention is to replicate the folder and component name")])]),t._v(" "),s("h3",{attrs:{id:"examples"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[t._v("#")]),t._v(" Examples")]),t._v(" "),s("ul",[s("li",[t._v("The AppHeader.vue single-file component's (SFC) spec file is named\n"),s("code",[t._v("AppHeader.spec.js")])]),t._v(" "),s("li",[t._v("Create a global component like "),s("code",[t._v("PageSection.vue")]),t._v(" in the "),s("code",[t._v("/tests/global")]),t._v("\ndirectory with the name "),s("code",[t._v("PageSection.spec.js")])]),t._v(" "),s("li",[t._v("Create a mixin like BVToastMixin  in the "),s("code",[t._v("/tests/mixins")]),t._v(" directory with the\nname "),s("code",[t._v("BVToastMixin.spec.js")]),t._v(" Running Tests")])]),t._v(" "),s("h2",{attrs:{id:"running-tests"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#running-tests"}},[t._v("#")]),t._v(" Running Tests")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("test:unit")]),t._v(" script will run all the test suites. Until the integration of\nthe test script with the continuous integration tool is complete, it needs to be\nrun manually before pushing up code for review. If you are working on fixing a\ntest that is failing, follow the guidelines for debugging a failed tests or\nfixing failed snapshot tests.")]),t._v(" "),s("h3",{attrs:{id:"debugging-a-failed-test"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#debugging-a-failed-test"}},[t._v("#")]),t._v(" Debugging a failed test")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("test:unit:debugger")]),t._v(" script will help to debug failing tests using the\nChrome Developer Tools. To debug a test:")]),t._v(" "),s("ol",[s("li",[t._v("Add a "),s("code",[t._v("debugger")]),t._v(" statement in the specifications file")]),t._v(" "),s("li",[t._v("Run the unit test in debugger mode")]),t._v(" "),s("li",[t._v("Open the Chrome browser and go to "),s("code",[t._v("chrome://inspect")])])]),t._v(" "),s("h3",{attrs:{id:"fixing-failed-snapshot-tests"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fixing-failed-snapshot-tests"}},[t._v("#")]),t._v(" Fixing failed snapshot tests")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("test:update")]),t._v(" script will update snapshot tests. If the UI has changed and\nthe snapshot tests are failing, after manually verifying the UI changes, run the\nupdate script to update the snapshots. Running "),s("code",[t._v("test:update")]),t._v(" can be dangerous,\nas it will update all snapshot tests.")]),t._v(" "),s("p",[t._v("It is critical to verify all snapshot tests before running the update script.\nThe easiest way is to run the unit test in watch mode, "),s("code",[t._v("npm run test:unit -- --watch")]),t._v(" and verify each snapshot.")]),t._v(" "),s("h2",{attrs:{id:"guidelines"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#guidelines"}},[t._v("#")]),t._v(" Guidelines")]),t._v(" "),s("ul",[s("li",[t._v("Avoid coupling test code to source code when testing functionality\n"),s("ul",[s("li",[t._v("If test cases fail during refactoring, the test case may be tightly\ncoupled with the application structure.")])])]),t._v(" "),s("li",[t._v("A test should not break if the functionality it tests has not changed")]),t._v(" "),s("li",[t._v("To maintain test readability, only pass in the data needed for the test to\nwork in your mock object")]),t._v(" "),s("li",[t._v("Avoid the creation of side-effects whenever possible")]),t._v(" "),s("li",[t._v("There is no return on investment for testing presentational HTML")]),t._v(" "),s("li",[t._v("Use "),s("code",[t._v("shallowMount")]),t._v(" rather than mount unless child component rendering is\nrequired")]),t._v(" "),s("li",[t._v("Avoid leaky tests by using "),s("code",[t._v("localVue")]),t._v(" for all plugin installs, for example,\nwhen testing a plugin like Vuex")])]),t._v(" "),s("h2",{attrs:{id:"components"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#components"}},[t._v("#")]),t._v(" Components")]),t._v(" "),s("h3",{attrs:{id:"what-to-test"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-to-test"}},[t._v("#")]),t._v(" What to test")]),t._v(" "),s("ol",[s("li",[t._v("Test the function's inputs and outputs\n"),s("ul",[s("li",[t._v("Test only dynamically generated output")]),t._v(" "),s("li",[t._v("Test only output that is part of the component contract")])])]),t._v(" "),s("li",[t._v("Test any side-effects")]),t._v(" "),s("li",[t._v("Test correct rendering using a snapshot test")])]),t._v(" "),s("h3",{attrs:{id:"what-not-to-test"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-not-to-test"}},[t._v("#")]),t._v(" What not to test")]),t._v(" "),s("ol",[s("li",[t._v("Don't test third-party functionality")]),t._v(" "),s("li",[t._v("Don't test the internals of your components or that specific functions are\ncalled. This can lead to unnecessary refactoring.")]),t._v(" "),s("li",[t._v("Don't go beyond the input and outputs of the component")]),t._v(" "),s("li",[t._v("Don't test the functionality of other libraries")]),t._v(" "),s("li",[t._v("Static components do not need unit tests, use snapshot testing")])]),t._v(" "),s("h3",{attrs:{id:"strategy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#strategy"}},[t._v("#")]),t._v(" Strategy")]),t._v(" "),s("ol",[s("li",[t._v("Define a component contract that is based upon the component API")]),t._v(" "),s("li",[t._v("Create smaller functions with a specific purpose to make testing easier")]),t._v(" "),s("li",[t._v("Test the component API by writing tests first and then writing code to fix\nthe tests")]),t._v(" "),s("li",[t._v("Add a snapshot test once the presentational layer is validated through manual\nvisual testing")])]),t._v(" "),s("h3",{attrs:{id:"snapshot-testing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#snapshot-testing"}},[t._v("#")]),t._v(" Snapshot Testing")]),t._v(" "),s("p",[t._v("A snapshot test is a comparison of the code from two different points in time.\nWhen the view is rendering as expected, a snapshot is taken and when the test\nsuite is run, this snapshot is compared to the current code to make sure nothing\nhas changed.")]),t._v(" "),s("p",[t._v("This type of testing is good for testing that static content output has not\nchanged due to any code updates or refactoring. Too many snapshots can slow down\ndevelopment during refactors. Typically, these are written once the UI\npresentational layer is complete and validated.")]),t._v(" "),s("h2",{attrs:{id:"vuex-store"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex-store"}},[t._v("#")]),t._v(" Vuex Store")]),t._v(" "),s("p",[t._v("There are two testing strategies for testing a Vuex store, which include testing\nstore parts separately or testing a running store instance. Each strategy has\nits pros and cons. Given the size of the store and the number of developers that\ncould potentially contribute to the project, the suggested strategy is to "),s("code",[t._v("test store parts separately")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"testing-store-parts-separately"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#testing-store-parts-separately"}},[t._v("#")]),t._v(" Testing Store Parts Separately")]),t._v(" "),s("p",[t._v("Testing the parts separately is easy since each of the parts is a JavaScript\nfunction. Store parts to test include "),s("code",[t._v("actions")]),t._v(", "),s("code",[t._v("getters")]),t._v(", and "),s("code",[t._v("mutations")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"actions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#actions"}},[t._v("#")]),t._v(" Actions")]),t._v(" "),s("p",[t._v("Since HTTP calls should never be used in a test, actions require extreme\nmocking. Mocking tests rely on assumptions and can lead to faulty tests.")]),t._v(" "),s("h4",{attrs:{id:"getters"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#getters"}},[t._v("#")]),t._v(" Getters")]),t._v(" "),s("p",[t._v("Getters are JavaScript functions that return an output. These are basic\nfunctions that may not require testing unless there is getter logic. Any logic\nin a getter should be tested.")]),t._v(" "),s("h4",{attrs:{id:"mutations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mutations"}},[t._v("#")]),t._v(" Mutations")]),t._v(" "),s("p",[t._v("Mutations are JavaScript functions that mutate the store state. These are basic\nfunctions that may not require testing unless there is mutation logic. Any logic\nin a mutation should be tested.")]),t._v(" "),s("h4",{attrs:{id:"pros"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pros"}},[t._v("#")]),t._v(" Pros")]),t._v(" "),s("ul",[s("li",[t._v("Easier to debug")]),t._v(" "),s("li",[t._v("Smaller tests")])]),t._v(" "),s("h4",{attrs:{id:"cons"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cons"}},[t._v("#")]),t._v(" Cons")]),t._v(" "),s("ul",[s("li",[t._v("Requires extreme mocking when testing actions")]),t._v(" "),s("li",[t._v("Tightly coupled with implementation details")]),t._v(" "),s("li",[t._v("More maintenance required when refactoring")])]),t._v(" "),s("h3",{attrs:{id:"testing-store-instance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#testing-store-instance"}},[t._v("#")]),t._v(" Testing Store Instance")]),t._v(" "),s("ul",[s("li",[t._v("Uses mutations and actions as inputs")]),t._v(" "),s("li",[t._v("State is the output")]),t._v(" "),s("li",[t._v("Requires the use of "),s("code",[t._v("localVue")]),t._v(" when creating the store to avoid leaky tests")])]),t._v(" "),s("h4",{attrs:{id:"pros-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pros-2"}},[t._v("#")]),t._v(" Pros")]),t._v(" "),s("ul",[s("li",[t._v("Avoids mocking and brittle tests")]),t._v(" "),s("li",[t._v("Refactoring does not break test unless contract changes")])]),t._v(" "),s("h4",{attrs:{id:"cons-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cons-2"}},[t._v("#")]),t._v(" Cons")]),t._v(" "),s("ul",[s("li",[t._v("Debugging is more difficult")])]),t._v(" "),s("h2",{attrs:{id:"vue-router"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-router"}},[t._v("#")]),t._v(" Vue Router")]),t._v(" "),s("ul",[s("li",[t._v("Our current structure does not warrant testing the vue router")]),t._v(" "),s("li",[t._v("If there is logic used for creating "),s("code",[t._v("RouteLink")]),t._v(" items, we should unit test\nthat functionality, which requires stubbing")]),t._v(" "),s("li",[t._v("When testing a vue router, it is important to use localVue")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://vuex.vuejs.org/guide/testing.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vuex Testing"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"resources"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resources"}},[t._v("#")]),t._v(" Resources")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://vue-test-utils.vuejs.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue Test Utils"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://vuejsdevelopers.com/2019/08/26/vue-what-to-unit-test-components/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Knowing What To Test — Vue Component Unit\nTesting"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.dev-tips-and-tricks.com/how-to-unit-test-a-vuex-store",target:"_blank",rel:"noopener noreferrer"}},[t._v("How to unit test a vuex\nStore"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);