# Redfish Privilege Checking System

This directory contains the privilege checking infrastructure for the OpenBMC
WebUI.

## Architecture Overview

The privilege checking system uses a build-time static metadata approach
optimized for embedded BMC firmware:

```
┌─────────────────────────────────────────────────────────────────┐
│                     Build Time                                   │
│  PrivilegeRegistry.json ──► add-privilege-metadata.ts            │
│         (DMTF)              ──► Attaches metadata to endpoints   │
└─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Runtime                                     │
│                                                                  │
│  ┌─────────────────┐     ┌─────────────────────────────────┐    │
│  │  Pinia Store    │     │  Vue Query                      │    │
│  │  (authStore)    │     │  (AccountService/Roles)         │    │
│  │  Session.Roles[]│     │  Role.AssignedPrivileges[]      │    │
│  └────────┬────────┘     └────────────────┬────────────────┘    │
│           │                               │                      │
│           └───────────────┬───────────────┘                      │
│                           ▼                                      │
│               ┌───────────────────────┐                          │
│               │ useSessionPrivileges()│                          │
│               │ Computes actual privs │                          │
│               └───────────┬───────────┘                          │
│                           │                                      │
│                           ▼                                      │
│               ┌───────────────────────┐                          │
│               │ canCall() /           │                          │
│               │ canCallEntity()       │                          │
│               │ Checks DMTF mappings  │                          │
│               └───────────────────────┘                          │
└─────────────────────────────────────────────────────────────────┘
```

## Key Concepts

### 1. Build-Time Metadata Injection

The `PrivilegeRegistry.json` file (from DMTF) is only used at build time. The
transformer extracts privilege mappings and embeds them as static data. The
registry file is NOT shipped to firmware.

### 2. Client State (Pinia)

The `authStore` (in `src/stores/auth.ts`) holds the user's session data
including `Session.Roles[]`. This is client-side state set on login.

### 3. Server State (Vue Query)

Role definitions with `AssignedPrivileges[]` are fetched from
`/redfish/v1/AccountService/Roles` via Vue Query. This provides the mapping from
role names to actual privileges.

### 4. Privilege Computation

`useSessionPrivileges()` combines:

- Client state: Which roles the user has (from Session)
- Server state: What privileges each role grants (from AccountService)

Result: Array of actual privilege names like `['Login', 'ConfigureComponents']`

## Usage

### Pattern 1: Generated Endpoints (canCall)

For endpoints generated by Orval that have attached metadata:

```typescript
import { canCall } from '@/api/privilege/endpointPrivileges';
import { patchAccountServiceAccountById } from '@/api/endpoints/redfish.dist';

// Simple boolean check
const canEditAccount = canCall(patchAccountServiceAccountById);

// With property override
const canChangePassword = canCall(patchAccountServiceAccountById, 'Password');
```

### Pattern 2: Dynamic Endpoints (canCallEntity)

For endpoints discovered at runtime (like `HttpPushUri`):

```typescript
import { canCallEntity } from '@/api/privilege/endpointPrivileges';

// Firmware upload uses dynamically discovered URIs
const canUpdateFirmware = canCallEntity('UpdateService', 'POST');
```

### Pattern 3: Full Result (usePrivilegeCheckEntity)

For showing what privileges are missing:

```vue
<script setup>
import { usePrivilegeCheckEntity } from '@/api/privilege/endpointPrivileges';

const privilegeCheck = usePrivilegeCheckEntity('UpdateService', 'POST');
</script>

<template>
  <b-alert v-if="!privilegeCheck.allowed" variant="warning" show>
    Missing privileges: {{ privilegeCheck.missingPrivileges.join(', ') }}
  </b-alert>
</template>
```

### Pattern 4: Direct Privilege Check

For checking specific privileges without an endpoint:

```typescript
import { useSessionPrivileges } from '@/api/composables/useSessionPrivileges';

const privileges = useSessionPrivileges();
const canConfigureUsers = computed(() =>
  privileges.value.includes('ConfigureUsers'),
);
```

## Files

| File                                       | Purpose                           |
| ------------------------------------------ | --------------------------------- |
| `endpointPrivileges.ts`                    | Core privilege checking logic     |
| `../composables/useSessionPrivileges.ts`   | Computes user's actual privileges |
| `../transformer/add-privilege-metadata.ts` | Build-time metadata injector      |
| `../../stores/auth.ts`                     | Pinia store for session state     |

## DMTF Privilege Model

The privilege model follows DMTF Redfish specification:

- **Standard Privileges**: Login, ConfigureManager, ConfigureUsers,
  ConfigureComponents, ConfigureSelf
- **OR of ANDs**: Multiple privilege sets mean user needs ALL privileges in at
  least ONE set
- **Property Overrides**: Some properties (like Password) have different
  requirements

Example from PrivilegeRegistry:

```json
{
  "Entity": "ManagerAccount",
  "OperationMap": {
    "GET": [
      { "Privilege": ["ConfigureManager"] },
      { "Privilege": ["ConfigureUsers"] },
      { "Privilege": ["ConfigureSelf"] }
    ]
  }
}
```

This means GET on ManagerAccount requires ConfigureManager OR ConfigureUsers OR
ConfigureSelf.

## Security Model

- **Client-side advisory**: Privilege checks hide/disable UI elements
- **Server validation required**: All operations are validated by the BMC
  backend
- **Fail-safe defaults**: No metadata = access denied (returns `false`)
- **Redfish compliant**: Uses Session.Roles[] and AccountService Role
  definitions

## Regenerating Privilege Metadata

When the PrivilegeRegistry or endpoints change:

```bash
# Download latest from DMTF
npm run schema:download

# Regenerate API client with metadata
npm run generate-api
```

The `add-privilege-metadata.ts` transformer runs as part of the API generation
pipeline.
